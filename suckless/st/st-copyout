#!/usr/bin/env bash

# Create a temporary file to hold the command output
tmpfile=$(mktemp /tmp/st-cmd-output.XXXXXX) || exit
trap 'rm -f "$tmpfile"; exit' 0 1 15

# Capture the output of the command, including the prompt and command name.
# We will keep everything for dmenu, and later strip the prompt/command name for clipboard.
sed 's/\x0//g' > "$tmpfile"

# Extract the shell prompt, assuming it starts with the user's username and ends with `$` or `#`.
ps1=$(awk 'NF{line=$1} END{print line}' "$tmpfile")

# Select which output to copy via dmenu. This keeps the prompt and command name in the list.
chosen=$(tac "$tmpfile" | awk -v ps1="$ps1" 'index($0,ps1) && c++' | dmenu -p "Copy which command's output?" -i -l 10)

# Now copy the output (excluding the prompt and command name) to the clipboard.
awk -v chosen="$chosen" -v ps1="$ps1" '
  $0==chosen{p=1;next}  # Skip the chosen line (it contains the prompt/command)
  p && !index($0,ps1){print}  # Only print the output, after the prompt/command
  p && index($0,ps1){p=0}   # Stop when we hit another prompt/command, ending this block
' "$tmpfile" | xclip -selection clipboard
